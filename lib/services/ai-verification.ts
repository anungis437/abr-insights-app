/**
 * AI Verification Service
 * 
 * Implements safety controls for AI-generated content:
 * - Citation verification against trusted sources
 * - Legal advice detection and blocking
 * - AI usage disclaimers
 * - Audit logging of all AI interactions
 * - Source attribution requirements
 * 
 * Context: Canadian tribunal guidance requires caution with AI in legal proceedings
 */

import { createClient } from '@/lib/supabase/server'

// Trusted source domains for citation verification
const TRUSTED_SOURCE_DOMAINS = [
  'canlii.org',
  'chrt-tcdp.gc.ca',
  'ohrc.on.ca',
  'canada.ca',
  'ontario.ca',
  'laws-lois.justice.gc.ca',
  'scc-csc.lexum.com',
]

// Legal advice indicators to block
const LEGAL_ADVICE_INDICATORS = [
  'you should sue',
  'file a lawsuit',
  'you have a case',
  'legal strategy',
  'court filing',
  'retain a lawyer',
  'this is legal advice',
  'as your lawyer',
  'legal representation',
  'litigation strategy',
]

// AI disclaimer text
export const AI_DISCLAIMER = `⚠️ **AI-Generated Content Notice**

This response was generated by AI and is for educational purposes only. It is NOT legal advice.

**Important:**
- Always verify information with primary sources
- Consult qualified professionals for specific guidance
- AI can make mistakes or provide outdated information
- Human review is required before using in formal proceedings

For legal matters, consult a licensed lawyer or qualified professional.`

export interface AIInteractionLog {
  id?: string
  organization_id: string
  user_id: string
  session_id: string
  interaction_type: 'chat' | 'coach' | 'case_analysis' | 'automation'
  prompt: string
  response: string
  model: string
  tokens_used?: number
  citations?: string[]
  flags?: string[]
  verified_sources?: string[]
  contains_legal_advice_warning: boolean
  human_reviewed: boolean
  created_at?: string
}

/**
 * Verify citations against trusted sources
 */
export function verifyCitations(text: string): {
  citations: string[]
  verifiedSources: string[]
  unverifiedSources: string[]
} {
  // Extract URLs and source references
  const urlRegex = /https?:\/\/[^\s)]+/g
  const urls = text.match(urlRegex) || []

  const citations: string[] = []
  const verifiedSources: string[] = []
  const unverifiedSources: string[] = []

  urls.forEach((url) => {
    citations.push(url)
    const domain = new URL(url).hostname.replace('www.', '')

    if (TRUSTED_SOURCE_DOMAINS.some((trusted) => domain.includes(trusted))) {
      verifiedSources.push(url)
    } else {
      unverifiedSources.push(url)
    }
  })

  // Also look for case citations (e.g., "Smith v. Jones, 2023 OHRC 123")
  const caseRegex = /\b\d{4}\s+[A-Z]{2,5}\s+\d+\b/g
  const caseCitations = text.match(caseRegex) || []
  citations.push(...caseCitations)

  return {
    citations,
    verifiedSources,
    unverifiedSources,
  }
}

/**
 * Detect if response contains legal advice framing
 */
export function detectLegalAdvice(text: string): {
  containsLegalAdvice: boolean
  indicators: string[]
} {
  const lowerText = text.toLowerCase()
  const foundIndicators: string[] = []

  LEGAL_ADVICE_INDICATORS.forEach((indicator) => {
    if (lowerText.includes(indicator)) {
      foundIndicators.push(indicator)
    }
  })

  return {
    containsLegalAdvice: foundIndicators.length > 0,
    indicators: foundIndicators,
  }
}

/**
 * Add AI disclaimer to response
 */
export function addAIDisclaimer(response: string): string {
  return `${response}\n\n---\n\n${AI_DISCLAIMER}`
}

/**
 * Block response if it contains legal advice
 */
export function blockLegalAdviceIfNeeded(response: string): {
  blocked: boolean
  safeResponse?: string
  reason?: string
} {
  const { containsLegalAdvice, indicators } = detectLegalAdvice(response)

  if (containsLegalAdvice) {
    return {
      blocked: true,
      safeResponse: `⚠️ **Response Blocked**

This response was blocked because it may contain specific legal advice, which our AI system is not permitted to provide.

**Detected indicators:** ${indicators.join(', ')}

**What you can do:**
- Rephrase your question to focus on educational information or general principles
- Consult the tribunal cases in our database for precedents
- Contact a licensed lawyer or legal professional for specific guidance
- Review our training courses for general knowledge on this topic

**Remember:** AI cannot replace professional legal counsel. For matters involving legal proceedings, always consult qualified professionals.`,
      reason: `Legal advice indicators detected: ${indicators.join(', ')}`,
    }
  }

  return { blocked: false }
}

/**
 * Validate AI response for safety
 */
export function validateAIResponse(response: string): {
  safe: boolean
  flags: string[]
  modifiedResponse: string
} {
  const flags: string[] = []
  let modifiedResponse = response

  // Check for legal advice
  const legalCheck = blockLegalAdviceIfNeeded(response)
  if (legalCheck.blocked) {
    return {
      safe: false,
      flags: ['LEGAL_ADVICE_BLOCKED'],
      modifiedResponse: legalCheck.safeResponse!,
    }
  }

  // Verify citations
  const { citations, verifiedSources, unverifiedSources } = verifyCitations(response)

  if (unverifiedSources.length > 0) {
    flags.push('UNVERIFIED_SOURCES')
  }

  if (citations.length === 0 && response.includes('according to') || response.includes('case law')) {
    flags.push('MISSING_CITATIONS')
  }

  // Add disclaimer
  modifiedResponse = addAIDisclaimer(response)

  return {
    safe: true,
    flags,
    modifiedResponse,
  }
}

/**
 * Log AI interaction to audit trail
 */
export async function logAIInteraction(
  log: Omit<AIInteractionLog, 'id' | 'created_at'>
): Promise<string> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('ai_interaction_logs')
    .insert({
      organization_id: log.organization_id,
      user_id: log.user_id,
      session_id: log.session_id,
      interaction_type: log.interaction_type,
      prompt: log.prompt,
      response: log.response,
      model: log.model,
      tokens_used: log.tokens_used,
      citations: log.citations,
      flags: log.flags,
      verified_sources: log.verified_sources,
      contains_legal_advice_warning: log.contains_legal_advice_warning,
      human_reviewed: log.human_reviewed || false,
    })
    .select('id')
    .single()

  if (error) {
    console.error('[AI Verification] Failed to log interaction:', error)
    throw error
  }

  return data.id
}

/**
 * Get AI interaction logs for audit
 */
export async function getAIInteractionLogs(
  organizationId: string,
  options?: {
    userId?: string
    interactionType?: AIInteractionLog['interaction_type']
    flagged?: boolean
    needsReview?: boolean
    startDate?: Date
    endDate?: Date
    limit?: number
  }
): Promise<AIInteractionLog[]> {
  const supabase = await createClient()

  let query = supabase
    .from('ai_interaction_logs')
    .select('*')
    .eq('organization_id', organizationId)
    .order('created_at', { ascending: false })

  if (options?.userId) {
    query = query.eq('user_id', options.userId)
  }

  if (options?.interactionType) {
    query = query.eq('interaction_type', options.interactionType)
  }

  if (options?.flagged) {
    query = query.not('flags', 'is', null)
  }

  if (options?.needsReview) {
    query = query.eq('human_reviewed', false)
  }

  if (options?.startDate) {
    query = query.gte('created_at', options.startDate.toISOString())
  }

  if (options?.endDate) {
    query = query.lte('created_at', options.endDate.toISOString())
  }

  if (options?.limit) {
    query = query.limit(options.limit)
  }

  const { data, error } = await query

  if (error) {
    console.error('[AI Verification] Failed to get logs:', error)
    throw error
  }

  return data || []
}

/**
 * Mark AI interaction as human-reviewed
 */
export async function markAsReviewed(
  logId: string,
  reviewedBy: string,
  notes?: string
): Promise<void> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('ai_interaction_logs')
    .update({
      human_reviewed: true,
      review_notes: notes,
      reviewed_by: reviewedBy,
      reviewed_at: new Date().toISOString(),
    })
    .eq('id', logId)

  if (error) {
    console.error('[AI Verification] Failed to mark as reviewed:', error)
    throw error
  }
}

/**
 * Get AI usage statistics
 */
export async function getAIUsageStats(
  organizationId: string,
  startDate: Date,
  endDate: Date
): Promise<{
  totalInteractions: number
  byType: Record<string, number>
  flaggedCount: number
  needsReviewCount: number
  averageTokensUsed: number
  uniqueUsers: number
}> {
  const supabase = await createClient()

  const { data: logs, error } = await supabase
    .from('ai_interaction_logs')
    .select('*')
    .eq('organization_id', organizationId)
    .gte('created_at', startDate.toISOString())
    .lte('created_at', endDate.toISOString())

  if (error) {
    console.error('[AI Verification] Failed to get stats:', error)
    throw error
  }

  const byType: Record<string, number> = {}
  let totalTokens = 0
  let tokenCount = 0
  const uniqueUserIds = new Set<string>()

  logs?.forEach((log) => {
    byType[log.interaction_type] = (byType[log.interaction_type] || 0) + 1
    uniqueUserIds.add(log.user_id)
    
    if (log.tokens_used) {
      totalTokens += log.tokens_used
      tokenCount++
    }
  })

  return {
    totalInteractions: logs?.length || 0,
    byType,
    flaggedCount: logs?.filter((l) => l.flags && l.flags.length > 0).length || 0,
    needsReviewCount: logs?.filter((l) => !l.human_reviewed).length || 0,
    averageTokensUsed: tokenCount > 0 ? Math.round(totalTokens / tokenCount) : 0,
    uniqueUsers: uniqueUserIds.size,
  }
}
